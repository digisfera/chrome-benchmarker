// Generated by CoffeeScript 1.8.0
(function() {
  var Benchmark, Chrome, async, extractTimestampData, findDebuggerEventInTree, findInTreeByType, maxConnectionTries, retryDelay, runTest, startTest, _,
    __slice = [].slice;

  Chrome = require('chrome-remote-interface');

  _ = require('lodash');

  async = require('async');

  maxConnectionTries = 10;

  retryDelay = 100;

  runTest = function(url, port, doneFun) {
    var chooseTab, delayOnError, done, tryConnect;
    done = _.once(doneFun);
    chooseTab = function(tabs) {
      return _(tabs).findIndex(function(t) {
        return t.url === url;
      });
    };
    delayOnError = function(delay, done) {
      return function() {
        var args, err, timeout;
        err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        timeout = err != null ? delay : 0;
        return _.delay((function() {
          return done.apply(null, [err].concat(__slice.call(args)));
        }), timeout);
      };
    };
    tryConnect = function(done) {
      var chromeConnection;
      done = delayOnError(retryDelay, done);
      chromeConnection = Chrome({
        port: port,
        chooseTab: chooseTab
      });
      chromeConnection.on('error', function(err) {
        return done(err);
      });
      return chromeConnection.on('connect', function(chrome) {
        return done(null, chrome);
      });
    };
    return async.retry(maxConnectionTries, tryConnect, function(err, chrome) {
      if (err) {
        return done(err);
      } else {
        return startTest(chrome, url, done);
      }
    });
  };

  startTest = function(chrome, url, done) {
    var benchmark;
    benchmark = new Benchmark();
    chrome.Timeline.start({
      includeCounters: true
    });
    chrome.on('Timeline.started', function() {
      return chrome.Page.navigate({
        url: url
      });
    });
    return chrome.on('Timeline.eventRecorded', function(evt) {
      var e;
      try {
        benchmark.processTimelineEvent(evt);
      } catch (_error) {
        e = _error;
        return done(e);
      }
      if (benchmark.completed) {
        chrome.close();
        return done(null, benchmark.results());
      }
    });
  };

  Benchmark = (function() {
    function Benchmark() {
      this.started = false;
      this.completed = false;
      this.testData = {};
      this.countedGarbageCollection = 0;
      this.uncountedGarbageCollectorEvents = [];
      this.lastCountedHeapUsage = null;
      this.lastCountersEventTime = null;
    }

    Benchmark.prototype.processTimelineEvent = function(rootEvt) {
      var countersEvents, gcEvents, timestampData, timestampEvents;
      if (this.completed) {
        return false;
      }
      countersEvents = findInTreeByType(rootEvt, 'UpdateCounters');
      gcEvents = findInTreeByType(rootEvt, 'GCEvent');
      timestampEvents = findInTreeByType(rootEvt, 'TimeStamp');
      timestampData = extractTimestampData(timestampEvents);
      if (timestampData.start) {
        if (this.started) {
          throw 'Test started more than once';
        }
        this.started = true;
        this.testData.startTime = timestampData.start.time;
        this.testData.startHeapUsage = this.currentHeapUsage();
      }
      this.processMemoryEvents(countersEvents, gcEvents);
      if (timestampData.end) {
        if (!this.started) {
          throw 'Test ended before starting';
        }
        this.testData.endTime = timestampData.end.time;
        this.testData.endHeapUsage = this.currentHeapUsage();
        this.completed = true;
      }
      return true;
    };

    Benchmark.prototype.processMemoryEvents = function(counters, gc) {
      var counted, evt, gcEventsToProcess, groupedGcEvents, lastCountersEvent, uncounted, _i, _len, _ref, _ref1;
      if (counters == null) {
        counters = [];
      }
      if (gc == null) {
        gc = [];
      }
      lastCountersEvent = _.max(counters, function(evt) {
        return evt.startTime;
      });
      if (lastCountersEvent === -Infinity) {
        lastCountersEvent = null;
      }
      if (lastCountersEvent) {
        if (this.lastCountersEventTime && !(lastCountersEvent.startTime > this.lastCountersEventTime)) {
          throw new Error("Unordered events");
        }
        this.lastCountersEventTime = lastCountersEvent.startTime;
        this.lastCountedHeapUsage = lastCountersEvent.data.jsHeapSizeUsed;
      }
      gcEventsToProcess = Array.prototype.concat(gc, this.uncountedGarbageCollectorEvents);
      groupedGcEvents = _.groupBy(gcEventsToProcess, (function(_this) {
        return function(evt) {
          return evt.endTime < _this.lastCountersEventTime;
        };
      })(this));
      counted = (_ref = groupedGcEvents["true"]) != null ? _ref : [];
      uncounted = (_ref1 = groupedGcEvents["false"]) != null ? _ref1 : [];
      for (_i = 0, _len = counted.length; _i < _len; _i++) {
        evt = counted[_i];
        this.countedGarbageCollection += evt.data.usedHeapSizeDelta;
      }
      return this.uncountedGarbageCollectorEvents = uncounted;
    };

    Benchmark.prototype.currentHeapUsage = function() {
      return this.lastCountedHeapUsage + this.countedGarbageCollection;
    };

    Benchmark.prototype.results = function() {
      if (this.completed) {
        return {
          time: this.testData.endTime - this.testData.startTime,
          memory: this.testData.endHeapUsage - this.testData.startHeapUsage
        };
      } else {
        return null;
      }
    };

    return Benchmark;

  })();

  findDebuggerEventInTree = function(evtRaw, f, results) {
    var child, evt, _i, _len, _ref, _ref1;
    if (results == null) {
      results = [];
    }
    evt = (evtRaw != null ? evtRaw.record : void 0) || evtRaw;
    if (f(evt)) {
      results.push(evt);
    }
    _ref1 = (_ref = evt != null ? evt.children : void 0) != null ? _ref : [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      child = _ref1[_i];
      findDebuggerEventInTree(child, f, results);
    }
    return results;
  };

  findInTreeByType = function(evt, eventType) {
    return findDebuggerEventInTree(evt, function(e) {
      return e.type === eventType;
    });
  };

  extractTimestampData = function(evts) {
    var findEventWithMessage;
    findEventWithMessage = function(message) {
      var evt;
      evt = _.find(evts, function(evt) {
        var _ref;
        return (evt != null ? (_ref = evt.data) != null ? _ref.message : void 0 : void 0) === message;
      });
      if (evt) {
        return {
          message: message,
          time: evt.startTime
        };
      } else {
        return null;
      }
    };
    return {
      start: findEventWithMessage('testStart'),
      end: findEventWithMessage('testEnd')
    };
  };

  module.exports = runTest;

}).call(this);
